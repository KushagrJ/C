// To understand the recursion, first assume that arr is a very large array.
// Now, prove that the quick_sort() function sorts any random 1-element subset
// of arr. Then, prove that it sorts any random 2-element subset of arr.
// Continuing in this manner, you will notice that it sorts any random n-element
// subset of arr.
// For eg., when proving that the function sorts any random 5-element subset of
// arr, you don't have to prove that it sorts the two smaller subsets obtained
// after the pivot has been sorted, as you have already proved that it sorts any
// random subset of arr with less than 5 elements.

// The recursion stops for either a 1-element array or a 0-element array.
// For a 0-element array, upper_index will be less than lower_index.
// When lower_index happens to be 0, then upper_index will be -1.
// This is why signed indices are used in this program, instead of unsigned ones.





#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdbool.h>

#define N 4

void permute(int**, int*, int*, int);
void quick_sort(int*, int, int);
int partition(int*, int, int);
int rand_int(int, int);

int main(void)
{
    srand((unsigned) time(NULL));

    int p = 1;
    for (int i = 2; i <= N; ++i)
        p *= i;

    int** permutations = malloc(p * sizeof (int*));

    if (permutations == NULL)
    {
        fprintf(stderr, "Unsuccessful allocation\n");
        return EXIT_FAILURE;
    }

    permutations[0] = malloc(N * sizeof (int));

    if (permutations[0] == NULL)
    {
        fprintf(stderr, "Unsuccessful allocation\n");
        return EXIT_FAILURE;
    }

    for (int i = 0; i < N; ++i)
        permutations[0][i] = i;

    int curr = 0;

    permute(permutations, &curr, permutations[0], 0);

    bool overall_sorting_is_successful = true;

    for (int i = 0; i < p; ++i)
    {
        printf("Before sorting: ");
        for (int j = 0; j < N; ++j)
            printf("%d ", permutations[i][j]);
        printf("\n");

        quick_sort(permutations[i], 0, N - 1);

        printf("After sorting: ");
        for (int j = 0; j < N; ++j)
            printf("%d ", permutations[i][j]);
        printf("\n");

        bool sorting_is_successful = true;

        for (int j = 1; j < N; ++j)
        {
            if (permutations[i][j - 1] > permutations[i][j])
            {
                sorting_is_successful = false;
                overall_sorting_is_successful = false;
                break;
            }
        }

        if (sorting_is_successful)
            printf("Success\n\n");
        else
            printf("Failure\n\n");
    }

    if (overall_sorting_is_successful)
        printf("Overall success\n");
    else
        printf("Overall failure\n");

    return EXIT_SUCCESS;
}

void permute(int** permutations, int* ptr_curr, int* source, int lo)
{
    if (lo == N - 1)
    {
        permutations[*ptr_curr] = source;
        ++(*ptr_curr);

        return;
    }

    permute(permutations, ptr_curr, source, lo + 1);

    for (int i = lo + 1; i < N; ++i)
    {
        int* new_source = malloc(N * sizeof(int));
        for (int j = 0; j < N; ++j)
            new_source[j] = source[j];

        int temp = new_source[lo];
        new_source[lo] = new_source[i];
        new_source[i] = temp;

        permute(permutations, ptr_curr, new_source, lo + 1);
    }
}

void quick_sort(int* arr, int lower_index, int upper_index)
{
    printf("Quicksort called\n");

    if (lower_index < upper_index)
    {
        int partitioning_index = partition(arr, lower_index, upper_index);

        quick_sort(arr, lower_index, partitioning_index);
        quick_sort(arr, partitioning_index + 1, upper_index);
    }
}

int partition(int* arr, int lower_index, int upper_index)
{
    int pivot = arr[rand_int(lower_index, upper_index - 1)];

    int i = lower_index - 1;
    int j = upper_index + 1;

    while (true)
    {
        do
            i++;
        while (arr[i] < pivot);

        do
            j--;
        while (arr[j] > pivot);

        if (i >= j)
            return j;

        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

// https://stackoverflow.com/q/11758809/13952371
// The range of the pseudo-random integers generated by rand() is [0, RAND_MAX],
// i.e. the size of this range is RAND_MAX + 1.
// So, if number_of_integers is greater than RAND_MAX + 1, then there is no way
// to get a uniform distribution.

int rand_int(int min, int max)
{
    long long number_of_integers = (long long) max - (long long) min + 1LL;

    if (number_of_integers > (long long) RAND_MAX + 1LL)
        return 0;

    long long extra = ((long long) RAND_MAX + 1LL) % number_of_integers;

    while (true)
    {
        long long x = (long long) rand();

        if (x < ((long long) RAND_MAX + 1LL) - extra)
            return min + (int) (x % number_of_integers);
    }
}





// Three of the various schemes of partitioning are -
// (1) Hoare's partitioning scheme 1
//     (given in CLRS)
// (2) Hoare's partitioning scheme 2
//     (using the conditions (i <= upper_index) && (arr[i] <= pivot)
//      and (j >= lower_index) && (arr[j] >= pivot))
// (3) Lomuto's partitioning scheme

// This program uses Hoare's partitioning scheme 1.
// In this partitioning scheme, the pivot doesn't reach its final position after
// partitioning, as opposed to in 'Hoare's partitioning scheme 2' and 'Lomuto's
// partitioning scheme'.
// Instead, the subarray gets partitioned with respect to the pivot and the
// pivot gets shifted to either of the two partitions, and hence, the final
// position of the pivot can't be predicted.
// Thus, the first inner call to quick_sort() is
// quick_sort(arr, lower_index, partitioning_index), instead of
// quick_sort(arr, lower_index, (partitioning_index - 1)).

// At first glance, it may seem that
//
//  ...
//  int i = (lower_index - 1);
//  int j = (upper_index + 1);
//
//  while (true)
//  {
//      do
//          i++;
//      while (arr[i] < pivot);
//
//      do
//          j--;
//      while (arr[j] > pivot);
//  ...
//
// can be simply replaced by
//
//  ...
//  int i = lower_index;
//  int j = upper_index;
//
//  while (true)
//  {
//      while (arr[i] < pivot);
//          i++;
//
//      while (arr[j] > pivot);
//          j--;
//  ...
//
// but, this is not the case.
//
// This is because the 'do-while' version causes i/j to advance to the
// next/previous element in the subarray in every iteration of the outer
// 'while(true)' loop before the condition checking is done, whereas the 'while'
// version causes i/j to remain at its previous position when the condition
// checking is done.
//
// The 'while' version causes an infinite loop in many test cases.
// For eg., arr[] = {0, 3, -1, 0, 2}, with arr[0] as the pivot.

// In Hoare's partitioning scheme 1, while (arr[i] < pivot) and
// while (arr[j] > pivot) automatically ensure that i and j don't run out of
// bounds.
// Thus, extra conditions for bound-checking aren't required.
// Proof?

// Do (i <= upper_index) && (arr[i] <= pivot) and
// (j >= lower_index) && (arr[j] >= pivot)) make the partitioning process
// faster, as i and j will approach each other more quickly?

// Do more research in order to understand quick sort properly.
// Specifically, see questions from Stack Overflow, understand the Wikipedia
// article on quick sort, and solve the problems from Introduction to
// Algorithms (chapter 7).

// For all 3 partitioning schemes, understand the following -
// (1) returning i vs returning j?
// (2) not being able to choose the first/last element as the pivot?
// (3) before returning, the elements in the range (j, i), or (j, i], or
//     [j, i), or [j, i] being equal to each other?