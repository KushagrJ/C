a = a + b, b = a - b, a = a - b; should not be used for swapping, as the result
may overflow.

For integers, (x & 1) evaluates to 1 if x is odd.

For unsigned integers, ((x / y) + (x % y != 0)) does ceiling division.
Another approach is to use ((x + y - 1) / y), but this may cause an overflow.
So, this approach should only be used when it is guaranteed that overflow will
not occur.

To sort an array when the range of inputs is known beforehand, a simplified
version of counting sort can be used.
For eg., to sort an array consisting only of 0's, 1's and 2's, the number of
0's, 1's and 2's in the input array can be counted (say n0, n1 and n2). Then, in
the array, the first n0 elements can be assigned 0, the next n1 elements can be
assigned 1 and the final n2 elements can be assigned 2.


--------------------------------------------------------------------------------


004-70-Climbing-Stairs-Harder-Version


    Problem :-

    A person is climbing a staircase, with 0 being the starting step.
    The topmost step is the n-th (non-negative integer) step.
    The person can climb 1 or 2 or ... or m (positive integer) steps at a time.
    In how many distinct ways can the person climb to the top?

    For eg., n = 3 and m = 2.
    Way 1: "0 -> 1 -> 3"
    Way 2: "0 -> 2 -> 3"
    Way 3: "0 -> 1 -> 2 -> 3"
    So, for n = 3 and m = 2, no. of distinct ways = 3.


    Solution (Divide-and-Conquer with Tabulation) :-

    Let ans[i] be the no. of distinct ways in which the person can climb to the
    i-th step, under the constraint that they can climb at most m steps at a
    time.
    Thus, the solution to the problem is ans[n].

    The base case is i = 0, for which ans[0] = 1, since for every value of m,
    there is only one way to go from the 0-th step to the 0-th step itself.

    Now, for every step i > 0,
        Since the person can climb at most m steps at a time,
        Therefore, we have the following cases -
            Case 1: The person climbs to the i-th step using a 1-step jump.
                    In this case, ans[i] = ans[i - 1], as " -> i" can be
                    appended to every distinct way to climb (i - 1) steps.
            Case 2: The person climbs to the i-th step using a 2-step jump.
                    In this case, ans[i] = ans[i - 2], as " -> i" can be
                    appended to every distinct way to climb (i - 2) steps.
            ...
            ...
            ...
            Case m: The person climbs to the i-th step using an m-step jump.
                    In this case, ans[i] = ans[i - m], as " -> i" can be
                    appended to every distinct way to climb (i - m) steps.
        Thus, ans[i] = (ans[i - 1] + ans[i - 2] + ... + ans[i - m]).


    The following procedure handles the edge cases by setting the values of
    ans[-1], ans[-2], ... equal to 0, as required :-

    ans[-m] = ans[-m + 1] = ans[-m + 2] = ... = ans[-1] = 0;
    ans[0] = 1;

    int current_sum = 0;

    for (int i = 1; i <= n; i++)
    {
        current_sum -= ans[i - m - 1];
        current_sum += ans[i - 1];

        ans[i] = current_sum;
    }

    [Instead of calculating the sum (ans[i - 1] + ans[i - 2] + ... + ans[i - m])
     every time, the leftmost element is subtracted from the current sum and the
     new rightmost element is added to the current sum]


--------------------------------------------------------------------------------
