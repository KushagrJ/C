--------------------------------------------------------------------------------


004-70-Climbing-Stairs-Harder-Version


    Problem :-

    A person is climbing a staircase, with 0 being the starting step.
    The topmost step is the n-th (non-negative integer) step.
    The person can climb 1 or 2 or ... or m (positive integer) steps at a time.
    In how many distinct ways can the person climb to the top?

    For eg., n = 3 and m = 2.
    Way 1: "0 -> 1 -> 3"
    Way 2: "0 -> 2 -> 3"
    Way 3: "0 -> 1 -> 2 -> 3"
    So, for n = 3 and m = 2, no. of distinct ways = 3.


    Solution (Divide-and-Conquer with Tabulation) :-

    Let ans[i] be the no. of distinct ways in which the person can climb to the
    i-th step, under the constraint that they can climb at most m steps at a
    time.
    Thus, the solution to the problem is ans[n].

    The base case is i = 0, for which ans[0] = 1, since for every value of m,
    there is only way to go from the 0-th step to the 0-th step itself.

    Now, for every step i > 0,
        Since the person can climb at most m steps at a time,
        Therefore, we have the following cases -
            Case 1: The person climbs to the i-th step using a 1-step jump.
                    In this case, ans[i] = ans[i - 1], as " -> i" can be
                    appended to every distinct way to climb (i - 1) steps.
            Case 2: The person climbs to the i-th step using a 2-step jump.
                    In this case, ans[i] = ans[i - 2], as " -> i" can be
                    appended to every distinct way to climb (i - 2) steps.
            ...
            ...
            ...
            Case m: The person climbs to the i-th step using an m-step jump.
                    In this case, ans[i] = ans[i - m], as " -> i" can be
                    appended to every distinct way to climb (i - m) steps.
        Thus, ans[i] = (ans[i - 1] + ans[i - 2] + ... + ans[i - m]).


    The following procedure handles the edge cases by setting the values of
    ans[-1], ans[-2], ... equal to 0, as required :-

    ans[-m] = ans[-m + 1] = ans[-m + 2] = ... = ans[-1] = 0;
    ans[0] = 1;

    int current_sum = 0;

    for (int i = 1; i <= n; i++)
    {
        current_sum -= ans[i - m - 1];
        current_sum += ans[i - 1];

        ans[i] = current_sum;
    }

    [Instead of calculating the sum (ans[i - 1] + ans[i - 2] + ... + ans[i - m])
     every time, the leftmost element is subtracted from the current sum and the
     new rightmost element is added to the current sum]


--------------------------------------------------------------------------------
